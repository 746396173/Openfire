{
  super(router,routingTable,serverName,socket,connection,useBlockingMode);
  int coreThreads=JiveGlobals.getIntProperty("xmpp.multiplex.processing.core.threads",10);
  int maxThreads=JiveGlobals.getIntProperty("xmpp.multiplex.processing.max.threads",100);
  int queueSize=JiveGlobals.getIntProperty("xmpp.multiplex.processing.queue",50);
  threadPool=new ThreadPoolExecutor(coreThreads,maxThreads,60,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(queueSize),new RejectedExecutionHandler(){
    /** 
 * Stores rejected tasks in the overflow queue.
 * @param r the rejected task.
 * @param executor thread pool executor.
 */
    public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      if (!executor.isShutdown()) {
        overflowBuffer.add(r);
      }
    }
  }
);
  Thread overflowThread=new Thread(){
    public void run(){
      while (!threadPool.isShutdown() && !threadPool.isTerminated()) {
        try {
          Runnable runnable=overflowBuffer.take();
          while (threadPool.getActiveCount() >= threadPool.getMaximumPoolSize()) {
            Thread.sleep(100);
          }
          threadPool.execute(runnable);
        }
 catch (        InterruptedException e) {
        }
catch (        Exception e) {
          Log.error("Error consuming overflow buffer",e);
        }
      }
    }
  }
;
  overflowThread.start();
}
