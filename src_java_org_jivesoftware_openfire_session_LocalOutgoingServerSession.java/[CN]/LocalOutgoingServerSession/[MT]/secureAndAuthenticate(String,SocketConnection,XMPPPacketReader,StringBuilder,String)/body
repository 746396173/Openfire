{
  final Logger log=LoggerFactory.getLogger(LocalOutgoingServerSession.class.getName() + "['" + hostname+ "']");
  Element features;
  log.debug("Indicating we want TLS to " + hostname);
  connection.deliverRawText("<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>");
  MXParser xpp=reader.getXPPParser();
  Element proceed=reader.parseDocument().getRootElement();
  if (proceed != null && proceed.getName().equals("proceed")) {
    log.debug("Negotiating TLS...");
    try {
      boolean needed=JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_CERTIFICATE_VERIFY,true) && JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_CERTIFICATE_CHAIN_VERIFY,true) && !JiveGlobals.getBooleanProperty(ConnectionSettings.Server.TLS_ACCEPT_SELFSIGNED_CERTS,false);
      connection.startTLS(true,hostname,needed ? Connection.ClientAuth.needed : Connection.ClientAuth.wanted);
    }
 catch (    Exception e) {
      log.debug("Got an exception whilst negotiating TLS: " + e.getMessage());
      throw e;
    }
    log.debug("TLS negotiation was successful.");
    if (!SASLAuthentication.verifyCertificates(connection.getPeerCertificates(),hostname,true)) {
      log.debug("X.509/PKIX failure on outbound session");
      if (ServerDialback.isEnabled() || ServerDialback.isEnabledForSelfSigned()) {
        log.debug("Will continue with dialback.");
      }
 else {
        log.warn("No TLS auth, but TLS auth required.");
        return null;
      }
    }
    connection.deliverRawText(openingStream.toString());
    xpp.setInput(new InputStreamReader(connection.getTLSStreamHandler().getInputStream(),CHARSET));
    for (int eventType=xpp.getEventType(); eventType != XmlPullParser.START_TAG; ) {
      eventType=xpp.next();
    }
    String id=xpp.getAttributeValue("","id");
    features=reader.parseDocument().getRootElement();
    if (features != null) {
      String policyName=JiveGlobals.getProperty(ConnectionSettings.Server.COMPRESSION_SETTINGS,Connection.CompressionPolicy.disabled.toString());
      Connection.CompressionPolicy compressionPolicy=Connection.CompressionPolicy.valueOf(policyName);
      if (Connection.CompressionPolicy.optional == compressionPolicy) {
        Element compression=features.element("compression");
        if (compression != null) {
          boolean zlibSupported=false;
          Iterator it=compression.elementIterator("method");
          while (it.hasNext()) {
            Element method=(Element)it.next();
            if ("zlib".equals(method.getTextTrim())) {
              zlibSupported=true;
            }
          }
          if (zlibSupported) {
            log.debug("Suppressing request to perform compression; unsupported in this version.");
            zlibSupported=false;
          }
          if (zlibSupported) {
            log.debug("Requesting stream compression (zlib).");
            connection.deliverRawText("<compress xmlns='http://jabber.org/protocol/compress'><method>zlib</method></compress>");
            Element answer=reader.parseDocument().getRootElement();
            if ("compressed".equals(answer.getName())) {
              connection.addCompression();
              connection.startCompression();
              log.debug("Stream compression was successful.");
              connection.deliverRawText(openingStream.toString());
              ZInputStream in=new ZInputStream(connection.getTLSStreamHandler().getInputStream());
              in.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
              xpp.setInput(new InputStreamReader(in,CHARSET));
              for (int eventType=xpp.getEventType(); eventType != XmlPullParser.START_TAG; ) {
                eventType=xpp.next();
              }
              features=reader.parseDocument().getRootElement();
              if (features == null) {
                log.debug("Error, EXTERNAL SASL was not offered.");
                return null;
              }
            }
 else {
              log.debug("Stream compression was rejected by " + hostname);
            }
          }
 else {
            log.debug("Stream compression found but zlib method is not supported by " + hostname);
          }
        }
 else {
          log.debug("Stream compression not supported by " + hostname);
        }
      }
      boolean saslEXTERNALoffered=false;
      if (features != null) {
        if (features.element("mechanisms") != null) {
          Iterator<Element> it=features.element("mechanisms").elementIterator();
          while (it.hasNext()) {
            Element mechanism=it.next();
            if ("EXTERNAL".equals(mechanism.getTextTrim())) {
              saslEXTERNALoffered=true;
              break;
            }
          }
        }
      }
      final boolean dialbackOffered=features.element("dialback") != null;
      log.debug("Offering dialback functionality: {}",dialbackOffered);
      log.debug("Offering EXTERNAL SASL: {}",saslEXTERNALoffered);
      LocalOutgoingServerSession result=null;
      if (saslEXTERNALoffered) {
        result=attemptSASLexternal(connection,xpp,reader,domain,hostname,id,openingStream);
      }
      if (result == null) {
        result=attemptDialbackOverTLS(connection,reader,domain,hostname,id);
      }
      return result;
    }
 else {
      log.debug("Cannot create outgoing server session, as neither SASL mechanisms nor SERVER DIALBACK were offered by " + hostname);
      return null;
    }
  }
 else {
    log.debug("Error, <proceed> was not received!");
    return null;
  }
}
