{
  try {
    cacheFactoryStrategy=(CacheFactoryStrategy)Class.forName(clusteredCacheFactoryClass,true,getClusteredCacheStrategyClassLoader()).newInstance();
    clusteringStarting=cacheFactoryStrategy.startCluster();
  }
 catch (  Exception e) {
    Log.error("Unable to start clustering - continuing in local mode",e);
  }
  if (!clusteringStarting) {
    cacheFactoryStrategy=localCacheFactoryStrategy;
  }
 else {
    if (statsThread == null) {
      statsThread=new Thread("Cache Stats"){
        private volatile boolean destroyed=false;
        @Override public void run(){
          XMPPServer.getInstance().addServerListener(new XMPPServerListener(){
            public void serverStarted(){
            }
            public void serverStopping(){
              destroyed=true;
            }
          }
);
          ClusterManager.addListener(new ClusterEventListener(){
            public void joinedCluster(){
            }
            public void joinedCluster(            byte[] nodeID){
            }
            public void leftCluster(){
              destroyed=true;
              ClusterManager.removeListener(this);
            }
            public void leftCluster(            byte[] nodeID){
            }
            public void markedAsSeniorClusterMember(){
            }
          }
);
          while (!destroyed && ClusterManager.isClusteringEnabled()) {
            try {
              cacheFactoryStrategy.updateCacheStats(caches);
            }
 catch (            Exception e) {
              Log.error(e.getMessage(),e);
            }
            try {
              sleep(10000);
            }
 catch (            InterruptedException ie) {
            }
          }
          statsThread=null;
          Log.debug("Cache stats thread terminated.");
        }
      }
;
      statsThread.setDaemon(true);
      statsThread.start();
    }
  }
}
