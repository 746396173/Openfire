def WriteRules(self, rules, extra_sources, extra_outputs):
    "Write Makefile code for any 'rules' from the gyp input.\n\n    extra_sources: a list that will be filled in with newly generated source\n                   files, if any\n    extra_outputs: a list that will be filled in with any outputs of these\n                   rules (used to make other pieces dependent on these rules)\n    "
    if (len(rules) == 0):
        return
    rule_trigger = ('%s_rule_trigger' % self.android_module)
    did_write_rule = False
    for rule in rules:
        if (len(rule.get('rule_sources', [])) == 0):
            continue
        did_write_rule = True
        name = make.StringToMakefileVariable(('%s_%s' % (self.relative_target, rule['rule_name'])))
        self.WriteLn(('\n### Generated for rule "%s":' % name))
        self.WriteLn(('# "%s":' % rule))
        inputs = rule.get('inputs')
        for rule_source in rule.get('rule_sources', []):
            (rule_source_dirname, rule_source_basename) = os.path.split(rule_source)
            (rule_source_root, rule_source_ext) = os.path.splitext(rule_source_basename)
            outputs = [self.ExpandInputRoot(out, rule_source_root, rule_source_dirname) for out in rule['outputs']]
            dirs = set()
            for out in outputs:
                if (not out.startswith('$')):
                    print ('WARNING: Rule for target %s writes output to local path %s' % (self.target, out))
                dir = os.path.dirname(out)
                if dir:
                    dirs.add(dir)
            extra_outputs += outputs
            if int(rule.get('process_outputs_as_sources', False)):
                extra_sources.extend(outputs)
            components = []
            for component in rule['action']:
                component = self.ExpandInputRoot(component, rule_source_root, rule_source_dirname)
                if ('$(RULE_SOURCES)' in component):
                    component = component.replace('$(RULE_SOURCES)', rule_source)
                components.append(component)
            command = gyp.common.EncodePOSIXShellList(components)
            cd_action = ('cd $(gyp_local_path)/%s; ' % self.path)
            command = (cd_action + command)
            if dirs:
                command = ((('mkdir -p %s' % ' '.join(dirs)) + '; ') + command)
            outputs = map(self.LocalPathify, outputs)
            main_output = outputs[0]
            self.WriteLn(('%s: gyp_local_path := $(LOCAL_PATH)' % main_output))
            self.WriteLn(('%s: gyp_intermediate_dir := $(abspath $(gyp_intermediate_dir))' % main_output))
            self.WriteLn(('%s: gyp_shared_intermediate_dir := $(abspath $(gyp_shared_intermediate_dir))' % main_output))
            self.WriteLn(('%s: export PATH := $(subst $(ANDROID_BUILD_PATHS),,$(PATH))' % main_output))
            main_output_deps = self.LocalPathify(rule_source)
            if inputs:
                main_output_deps += ' '
                main_output_deps += ' '.join([self.LocalPathify(f) for f in inputs])
            self.WriteLn(('%s: %s $(GYP_TARGET_DEPENDENCIES)' % (main_output, main_output_deps)))
            self.WriteLn(('\t%s\n' % command))
            for output in outputs[1:]:
                self.WriteLn(('%s: %s ;' % (output, main_output)))
            self.WriteLn(('.PHONY: %s' % rule_trigger))
            self.WriteLn(('%s: %s' % (rule_trigger, main_output)))
            self.WriteLn('')
    if did_write_rule:
        extra_sources.append(rule_trigger)
        self.WriteLn('### Finished generating for all rules')
        self.WriteLn('')
