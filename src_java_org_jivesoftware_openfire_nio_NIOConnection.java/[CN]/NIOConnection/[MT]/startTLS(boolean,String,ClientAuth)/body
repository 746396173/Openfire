{
  boolean c2s=(remoteServer == null);
  KeyStore ksKeys=SSLConfig.getKeyStore();
  String keypass=SSLConfig.getKeyPassword();
  KeyStore ksTrust=(c2s ? SSLConfig.getc2sTrustStore() : SSLConfig.gets2sTrustStore());
  String trustpass=(c2s ? SSLConfig.getc2sTrustPassword() : SSLConfig.gets2sTrustPassword());
  if (c2s)   Log.debug("NIOConnection: startTLS: using c2s");
 else   Log.debug("NIOConnection: startTLS: using s2s");
  KeyManager[] km=SSLJiveKeyManagerFactory.getKeyManagers(ksKeys,keypass);
  TrustManager[] tm=SSLJiveTrustManagerFactory.getTrustManagers(ksTrust,trustpass);
  if (clientMode || authentication == ClientAuth.needed || authentication == ClientAuth.wanted) {
    if (c2s) {
      tm=new TrustManager[]{new ClientTrustManager(ksTrust)};
    }
 else {
      tm=new TrustManager[]{new ServerTrustManager(remoteServer,ksTrust,this)};
    }
  }
  String algorithm=JiveGlobals.getProperty(ConnectionSettings.Client.TLS_ALGORITHM,"TLS");
  SSLContext tlsContext=SSLContext.getInstance(algorithm);
  tlsContext.init(km,tm,null);
  SslFilter filter=new SslFilter(tlsContext);
  filter.setUseClientMode(clientMode);
  if (clientMode) {
    filter.setEnabledProtocols(new String[]{"TLSv1","TLSv1.1","TLSv1.2"});
  }
 else {
    filter.setEnabledProtocols(new String[]{"SSLv2Hello","TLSv1","TLSv1.1","TLSv1.2"});
  }
  if (authentication == ClientAuth.needed) {
    filter.setNeedClientAuth(true);
  }
 else   if (authentication == ClientAuth.wanted) {
    filter.setWantClientAuth(true);
  }
  ioSession.getFilterChain().addBefore(EXECUTOR_FILTER_NAME,TLS_FILTER_NAME,filter);
  ioSession.setAttribute(SslFilter.DISABLE_ENCRYPTION_ONCE,Boolean.TRUE);
  if (!clientMode) {
    deliverRawText("<proceed xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"/>");
  }
}
