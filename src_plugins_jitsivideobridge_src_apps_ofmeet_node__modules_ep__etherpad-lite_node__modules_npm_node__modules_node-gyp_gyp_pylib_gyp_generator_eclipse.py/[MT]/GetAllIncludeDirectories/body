def GetAllIncludeDirectories(target_list, target_dicts, shared_intermediate_dirs, config_name, params):
    "Calculate the set of include directories to be used.\n\n  Returns:\n    A list including all the include_dir's specified for every target followed\n    by any include directories that were added as cflag compiler options.\n  "
    gyp_includes_set = set()
    compiler_includes_list = []
    flavor = gyp.common.GetFlavor(params)
    if (flavor == 'win'):
        generator_flags = params.get('generator_flags', {})
    for target_name in target_list:
        target = target_dicts[target_name]
        if (config_name in target['configurations']):
            config = target['configurations'][config_name]
            if (flavor == 'win'):
                msvs_settings = gyp.msvs_emulation.MsvsSettings(target, generator_flags)
                cflags = msvs_settings.GetCflags(config_name)
            else:
                cflags = config['cflags']
            for cflag in cflags:
                include_dir = ''
                if cflag.startswith('-I'):
                    include_dir = cflag[2:]
                if (include_dir and (not (include_dir in compiler_includes_list))):
                    compiler_includes_list.append(include_dir)
            if config.has_key('include_dirs'):
                include_dirs = config['include_dirs']
                for shared_intermediate_dir in shared_intermediate_dirs:
                    for include_dir in include_dirs:
                        include_dir = include_dir.replace('$SHARED_INTERMEDIATE_DIR', shared_intermediate_dir)
                        if (not os.path.isabs(include_dir)):
                            base_dir = os.path.dirname(target_name)
                            include_dir = ((base_dir + '/') + include_dir)
                            include_dir = os.path.abspath(include_dir)
                        if (not (include_dir in gyp_includes_set)):
                            gyp_includes_set.add(include_dir)
    all_includes_list = list(gyp_includes_set)
    all_includes_list.sort()
    for compiler_include in compiler_includes_list:
        if (not (compiler_include in gyp_includes_set)):
            all_includes_list.append(compiler_include)
    return all_includes_list
