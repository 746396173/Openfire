{
  StringBuilder sb;
  String recipient=doc.attributeValue("to");
  String hostname=doc.attributeValue("from");
  Log.debug("ServerDialback: RS - Received dialback key from host: " + hostname + " to: "+ recipient);
  if (!RemoteServerManager.canAccess(hostname)) {
    connection.deliverRawText(new StreamError(StreamError.Condition.policy_violation).toXML());
    connection.close();
    Log.debug("ServerDialback: RS - Error, hostname is not allowed to establish a connection to " + "this server: " + recipient);
    return false;
  }
 else   if (isHostUnknown(recipient)) {
    dialbackError(recipient,hostname,new PacketError(PacketError.Condition.item_not_found,PacketError.Type.cancel,"Service not hosted here"));
    Log.debug("ServerDialback: RS - Error, hostname not recognized: " + recipient);
    return false;
  }
 else {
    boolean alreadyExists=false;
    for (    IncomingServerSession session : sessionManager.getIncomingServerSessions(hostname)) {
      if (recipient.equals(session.getLocalDomain())) {
        alreadyExists=true;
      }
    }
    if (alreadyExists && !sessionManager.isMultipleServerConnectionsAllowed()) {
      connection.deliverRawText(new StreamError(StreamError.Condition.not_authorized).toXML());
      connection.close();
      Log.debug("ServerDialback: RS - Error, incoming connection already exists from: " + hostname);
      return false;
    }
 else {
      String key=doc.getTextTrim();
      List<DNSUtil.HostAddress> hosts=DNSUtil.resolveXMPPDomain(hostname,RemoteServerManager.getPortForServer(hostname));
      Socket socket=new Socket();
      String realHostname=null;
      int realPort;
      for (Iterator<DNSUtil.HostAddress> it=hosts.iterator(); it.hasNext(); ) {
        try {
          DNSUtil.HostAddress address=it.next();
          realHostname=address.getHost();
          realPort=address.getPort();
          Log.debug("ServerDialback: RS - Trying to connect to Authoritative Server: " + hostname + "(DNS lookup: "+ realHostname+ ":"+ realPort+ ")");
          socket.connect(new InetSocketAddress(realHostname,realPort),RemoteServerManager.getSocketTimeout());
          Log.debug("ServerDialback: RS - Connection to AS: " + hostname + " successful");
          break;
        }
 catch (        Exception e) {
          Log.warn("Error trying to connect to remote server: " + hostname + "(DNS lookup: "+ realHostname+ ")",e);
        }
      }
      if (!socket.isConnected()) {
        dialbackError(recipient,hostname,new PacketError(PacketError.Condition.remote_server_not_found,PacketError.Type.cancel,"Unable to connect to authoritative server"));
        Log.warn("No server available for verifying key of remote server: " + hostname);
        try {
          socket.close();
        }
 catch (        IOException e) {
          Log.warn("Socket error on close",e);
        }
        return false;
      }
      try {
        VerifyResult result=verifyKey(key,streamID.toString(),recipient,hostname,socket);
switch (result) {
case valid:
case invalid:
          boolean valid=(result == VerifyResult.valid);
        Log.debug("ServerDialback: RS - Sending key verification result to OS: " + hostname);
      sb=new StringBuilder();
    sb.append("<db:result");
  sb.append(" from=\"").append(recipient).append("\"");
sb.append(" to=\"").append(hostname).append("\"");
sb.append(" type=\"");
sb.append(valid ? "valid" : "invalid");
sb.append("\"/>");
connection.deliverRawText(sb.toString());
if (!valid) {
connection.close();
}
return valid;
default :
break;
}
dialbackError(recipient,hostname,new PacketError(PacketError.Condition.remote_server_timeout,PacketError.Type.cancel,"Authoritative server returned error"));
return false;
}
 catch (Exception e) {
dialbackError(recipient,hostname,new PacketError(PacketError.Condition.remote_server_timeout,PacketError.Type.cancel,"Authoritative server failed"));
Log.warn("Error verifying key of remote server: " + hostname,e);
return false;
}
}
}
}
