{
  JID recipientJID=packet.getTo();
  if (recipientJID != null && recipientJID.getNode() == null && recipientJID.getResource() == null && serverName.equals(recipientJID.getDomain())) {
    Element childElement=packet.getChildElement();
    if (childElement != null && childElement.element("addresses") != null) {
      multicastRouter.route(packet);
      return;
    }
 else     if (IQ.Type.result == packet.getType() || IQ.Type.error == packet.getType()) {
      IQResultListener iqResultListener=resultListeners.remove(packet.getID());
      if (iqResultListener != null) {
        try {
          iqResultListener.receivedAnswer(packet);
        }
 catch (        Exception e) {
          Log.error("Error processing answer of remote entity",e);
        }
        return;
      }
    }
  }
  try {
    if (recipientJID != null) {
      RoutableChannelHandler serviceRoute=routingTable.getRoute(recipientJID);
      if (serviceRoute != null && !(serviceRoute instanceof ClientSession)) {
        serviceRoute.process(packet);
        return;
      }
    }
    if (isLocalServer(recipientJID)) {
      Element childElement=packet.getChildElement();
      String namespace=null;
      if (childElement != null) {
        namespace=childElement.getNamespaceURI();
      }
      if (namespace == null) {
        if (packet.getType() != IQ.Type.result) {
          Log.warn("Unknown packet " + packet);
        }
      }
 else {
        IQHandler handler=getHandler(namespace);
        if (handler == null) {
          IQ reply=IQ.createResultIQ(packet);
          if (recipientJID == null) {
            reply.setChildElement(packet.getChildElement().createCopy());
            reply.setError(PacketError.Condition.service_unavailable);
          }
 else           if (recipientJID.getNode() == null || "".equals(recipientJID.getNode())) {
            reply.setChildElement(packet.getChildElement().createCopy());
            reply.setError(PacketError.Condition.feature_not_implemented);
          }
 else {
            reply.setChildElement(packet.getChildElement().createCopy());
            reply.setError(PacketError.Condition.service_unavailable);
          }
          ChannelHandler route=routingTable.getRoute(packet.getFrom());
          if (route != null) {
            route.process(reply);
          }
 else {
            Session session=sessionManager.getSession(packet.getFrom());
            if (session != null) {
              session.process(reply);
            }
 else {
              Log.warn("Packet could not be delivered " + packet);
            }
          }
        }
 else {
          handler.process(packet);
        }
      }
    }
 else {
      boolean handlerFound=false;
      if (XMPPServer.getInstance().isLocal(recipientJID)) {
        Session session=sessionManager.getBestRoute(recipientJID);
        if (session != null) {
          session.process(packet);
          handlerFound=true;
        }
 else {
          Log.info("Packet sent to unreachable address " + packet);
        }
      }
 else {
        ChannelHandler route=routingTable.getRoute(recipientJID);
        if (route != null) {
          route.process(packet);
          handlerFound=true;
        }
 else {
          Log.info("Packet sent to unreachable address " + packet);
        }
      }
      if (!handlerFound && IQ.Type.result != packet.getType()) {
        IQ reply=IQ.createResultIQ(packet);
        reply.setChildElement(packet.getChildElement().createCopy());
        reply.setError(PacketError.Condition.service_unavailable);
        ChannelHandler route=routingTable.getRoute(packet.getFrom());
        if (route != null) {
          route.process(reply);
        }
 else {
          Session session=sessionManager.getSession(packet.getFrom());
          if (session != null) {
            session.process(reply);
          }
 else {
            Log.warn("Packet could not be delivered " + reply);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    Log.error(LocaleUtils.getLocalizedString("admin.error.routing"),e);
    Session session=sessionManager.getSession(packet.getFrom());
    if (session != null) {
      Connection conn=session.getConnection();
      if (conn != null) {
        conn.close();
      }
    }
  }
}
