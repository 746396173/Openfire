{
  BridgeSelector bridgeSelector=services.getBridgeSelector();
  Iterator<String> bridgesIterator=bridgeSelector.getPrioritizedBridgesList().iterator();
  if (StringUtils.isNullOrEmpty(colibri.getJitsiVideobridge())) {
    if (!bridgesIterator.hasNext()) {
      throw new OperationFailedException("Failed to allocate channels - no bridge configured",OperationFailedException.GENERAL_ERROR);
    }
    colibri.setJitsiVideobridge(bridgesIterator.next());
  }
  boolean conferenceExists=colibri.getConferenceId() != null;
  while (true) {
    try {
      ColibriConferenceIQ peerChannels=colibri.createColibriChannels(peer.hasBundleSupport(),peer.getChatMember().getName(),true,contents);
      bridgeSelector.updateBridgeOperationalStatus(colibri.getJitsiVideobridge(),true);
      if (!conferenceExists) {
        String conferenceId=colibri.getConferenceId();
        if (conferenceId != null) {
          LoggingService loggingService=FocusBundleActivator.getLoggingService();
          if (loggingService != null) {
            loggingService.logEvent(LogEventFactory.conferenceRoom(conferenceId,roomName));
          }
          CallControlComponent.self.conferences.put(roomName,conferenceId);
        }
      }
      return peerChannels;
    }
 catch (    OperationFailedException exc) {
      String faultyBridge=colibri.getJitsiVideobridge();
      logger.error("Failed to allocate channels using bridge: " + colibri.getJitsiVideobridge(),exc);
      bridgeSelector.updateBridgeOperationalStatus(faultyBridge,false);
      if (!StringUtils.isNullOrEmpty(colibri.getConferenceId())) {
        logger.error("Bridge failure - stopping the conference");
        stop();
      }
 else       if (!bridgesIterator.hasNext()) {
        throw new OperationFailedException("Failed to allocate channels - all bridges are faulty",BRIDGE_FAILURE_ERR_CODE);
      }
 else {
        colibri.setJitsiVideobridge(bridgesIterator.next());
      }
    }
  }
}
