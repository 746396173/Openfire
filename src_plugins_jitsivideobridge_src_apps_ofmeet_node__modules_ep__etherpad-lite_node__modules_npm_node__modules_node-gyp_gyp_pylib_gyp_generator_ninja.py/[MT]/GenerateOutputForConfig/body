def GenerateOutputForConfig(target_list, target_dicts, data, params, config_name):
    options = params['options']
    flavor = gyp.common.GetFlavor(params)
    generator_flags = params.get('generator_flags', {})
    build_dir = os.path.normpath(os.path.join(ComputeOutputDir(params), config_name))
    toplevel_build = os.path.join(options.toplevel_dir, build_dir)
    master_ninja = ninja_syntax.Writer(OpenOutput(os.path.join(toplevel_build, 'build.ninja')), width=120)
    gyp.common.CopyTool(flavor, toplevel_build)
    if (flavor == 'win'):
        cc = 'cl.exe'
        cxx = 'cl.exe'
        ld = 'link.exe'
        ld_host = '$ld'
    else:
        cc = 'gcc'
        cxx = 'g++'
        ld = '$cc'
        ldxx = '$cxx'
        ld_host = '$cc_host'
        ldxx_host = '$cxx_host'
    cc_host = None
    cxx_host = None
    cc_host_global_setting = None
    cxx_host_global_setting = None
    (build_file, _, _) = gyp.common.ParseQualifiedTarget(target_list[0])
    make_global_settings = data[build_file].get('make_global_settings', [])
    build_to_root = gyp.common.InvertRelativePath(build_dir, options.toplevel_dir)
    wrappers = {}
    for (key, value) in make_global_settings:
        if (key == 'CC'):
            cc = os.path.join(build_to_root, value)
        if (key == 'CXX'):
            cxx = os.path.join(build_to_root, value)
        if (key == 'CC.host'):
            cc_host = os.path.join(build_to_root, value)
            cc_host_global_setting = value
        if (key == 'CXX.host'):
            cxx_host = os.path.join(build_to_root, value)
            cxx_host_global_setting = value
        if key.endswith('_wrapper'):
            wrappers[key[:(- len('_wrapper'))]] = os.path.join(build_to_root, value)
    for (key, value) in os.environ.iteritems():
        if key.lower().endswith('_wrapper'):
            key_prefix = key[:(- len('_wrapper'))]
            key_prefix = re.sub('\\.HOST$', '.host', key_prefix)
            wrappers[key_prefix] = os.path.join(build_to_root, value)
    if (flavor == 'win'):
        cl_paths = gyp.msvs_emulation.GenerateEnvironmentFiles(toplevel_build, generator_flags, OpenOutput)
        for (arch, path) in cl_paths.iteritems():
            master_ninja.variable(('cl_' + arch), CommandWithWrapper('CC', wrappers, QuoteShellArgument(path, flavor)))
    cc = GetEnvironFallback(['CC_target', 'CC'], cc)
    master_ninja.variable('cc', CommandWithWrapper('CC', wrappers, cc))
    cxx = GetEnvironFallback(['CXX_target', 'CXX'], cxx)
    master_ninja.variable('cxx', CommandWithWrapper('CXX', wrappers, cxx))
    if (flavor == 'win'):
        master_ninja.variable('ld', ld)
        master_ninja.variable('idl', 'midl.exe')
        master_ninja.variable('ar', 'lib.exe')
        master_ninja.variable('rc', 'rc.exe')
        master_ninja.variable('asm', 'ml.exe')
        master_ninja.variable('mt', 'mt.exe')
    else:
        master_ninja.variable('ld', CommandWithWrapper('LINK', wrappers, ld))
        master_ninja.variable('ldxx', CommandWithWrapper('LINK', wrappers, ldxx))
        master_ninja.variable('ar', GetEnvironFallback(['AR_target', 'AR'], 'ar'))
    if generator_supports_multiple_toolsets:
        if (not cc_host):
            cc_host = cc
        if (not cxx_host):
            cxx_host = cxx
        master_ninja.variable('ar_host', GetEnvironFallback(['AR_host'], 'ar'))
        cc_host = GetEnvironFallback(['CC_host'], cc_host)
        cxx_host = GetEnvironFallback(['CXX_host'], cxx_host)
        if (('$(CC)' in cc_host) and cc_host_global_setting):
            cc_host = cc_host_global_setting.replace('$(CC)', cc)
        if (('$(CXX)' in cxx_host) and cxx_host_global_setting):
            cxx_host = cxx_host_global_setting.replace('$(CXX)', cxx)
        master_ninja.variable('cc_host', CommandWithWrapper('CC.host', wrappers, cc_host))
        master_ninja.variable('cxx_host', CommandWithWrapper('CXX.host', wrappers, cxx_host))
        if (flavor == 'win'):
            master_ninja.variable('ld_host', ld_host)
        else:
            master_ninja.variable('ld_host', CommandWithWrapper('LINK', wrappers, ld_host))
            master_ninja.variable('ldxx_host', CommandWithWrapper('LINK', wrappers, ldxx_host))
    master_ninja.newline()
    master_ninja.pool('link_pool', depth=GetDefaultConcurrentLinks())
    master_ninja.newline()
    deps = ('msvc' if (flavor == 'win') else 'gcc')
    if (flavor != 'win'):
        master_ninja.rule('cc', description='CC $out', command='$cc -MMD -MF $out.d $defines $includes $cflags $cflags_c $cflags_pch_c -c $in -o $out', depfile='$out.d', deps=deps)
        master_ninja.rule('cc_s', description='CC $out', command='$cc $defines $includes $cflags $cflags_c $cflags_pch_c -c $in -o $out')
        master_ninja.rule('cxx', description='CXX $out', command='$cxx -MMD -MF $out.d $defines $includes $cflags $cflags_cc $cflags_pch_cc -c $in -o $out', depfile='$out.d', deps=deps)
    else:
        cc_command = ('ninja -t msvc -e $arch ' + '-- $cc /nologo /showIncludes /FC @$out.rsp /c $in /Fo$out /Fd$pdbname ')
        cxx_command = ('ninja -t msvc -e $arch ' + '-- $cxx /nologo /showIncludes /FC @$out.rsp /c $in /Fo$out /Fd$pdbname ')
        master_ninja.rule('cc', description='CC $out', command=cc_command, rspfile='$out.rsp', rspfile_content='$defines $includes $cflags $cflags_c', deps=deps)
        master_ninja.rule('cxx', description='CXX $out', command=cxx_command, rspfile='$out.rsp', rspfile_content='$defines $includes $cflags $cflags_cc', deps=deps)
        master_ninja.rule('idl', description='IDL $in', command=('%s gyp-win-tool midl-wrapper $arch $outdir $tlb $h $dlldata $iid $proxy $in $idlflags' % sys.executable))
        master_ninja.rule('rc', description='RC $in', command=('%s gyp-win-tool rc-wrapper $arch $rc $defines $resource_includes $rcflags /fo$out $in' % sys.executable))
        master_ninja.rule('asm', description='ASM $in', command=('%s gyp-win-tool asm-wrapper $arch $asm $defines $includes /c /Fo $out $in' % sys.executable))
    if ((flavor != 'mac') and (flavor != 'win')):
        master_ninja.rule('alink', description='AR $out', command='rm -f $out && $ar rcs $out $in')
        master_ninja.rule('alink_thin', description='AR $out', command='rm -f $out && $ar rcsT $out $in')
        mtime_preserving_solink_base = ('if [ ! -e $lib -o ! -e ${lib}.TOC ]; then %(solink)s && %(extract_toc)s > ${lib}.TOC; else %(solink)s && %(extract_toc)s > ${lib}.tmp && if ! cmp -s ${lib}.tmp ${lib}.TOC; then mv ${lib}.tmp ${lib}.TOC ; fi; fi' % {'solink': '$ld -shared $ldflags -o $lib -Wl,-soname=$soname %(suffix)s', 'extract_toc': "{ readelf -d ${lib} | grep SONAME ; nm -gD -f p ${lib} | cut -f1-2 -d' '; }", })
        master_ninja.rule('solink', description='SOLINK $lib', restat=True, command=(mtime_preserving_solink_base % {'suffix': '-Wl,--whole-archive $in $solibs -Wl,--no-whole-archive $libs', }), pool='link_pool')
        master_ninja.rule('solink_module', description='SOLINK(module) $lib', restat=True, command=(mtime_preserving_solink_base % {'suffix': '-Wl,--start-group $in $solibs -Wl,--end-group $libs', }), pool='link_pool')
        master_ninja.rule('link', description='LINK $out', command='$ld $ldflags -o $out -Wl,--start-group $in $solibs -Wl,--end-group $libs', pool='link_pool')
    elif (flavor == 'win'):
        master_ninja.rule('alink', description='LIB $out', command=('%s gyp-win-tool link-wrapper $arch $ar /nologo /ignore:4221 /OUT:$out @$out.rsp' % sys.executable), rspfile='$out.rsp', rspfile_content='$in_newline $libflags')
        _AddWinLinkRules(master_ninja, embed_manifest=True, link_incremental=True)
        _AddWinLinkRules(master_ninja, embed_manifest=True, link_incremental=False)
        _AddWinLinkRules(master_ninja, embed_manifest=False, link_incremental=False)
    else:
        master_ninja.rule('objc', description='OBJC $out', command='$cc -MMD -MF $out.d $defines $includes $cflags $cflags_objc $cflags_pch_objc -c $in -o $out', depfile='$out.d', deps=deps)
        master_ninja.rule('objcxx', description='OBJCXX $out', command='$cxx -MMD -MF $out.d $defines $includes $cflags $cflags_objcc $cflags_pch_objcc -c $in -o $out', depfile='$out.d', deps=deps)
        master_ninja.rule('alink', description='LIBTOOL-STATIC $out, POSTBUILDS', command='rm -f $out && ./gyp-mac-tool filter-libtool libtool $libtool_flags -static -o $out $in$postbuilds')
        master_ninja.rule('lipo', description='LIPO $out, POSTBUILDS', command='rm -f $out && lipo -create $in -output $out$postbuilds')
        solink_base = '$ld %(type)s $ldflags -o $lib %(suffix)s'
        mtime_preserving_solink_base = ('if [ ! -e $lib -o ! -e ${lib}.TOC ] || otool -l $lib | grep -q LC_REEXPORT_DYLIB ; then %(solink)s && %(extract_toc)s > ${lib}.TOC; else %(solink)s && %(extract_toc)s > ${lib}.tmp && if ! cmp -s ${lib}.tmp ${lib}.TOC; then mv ${lib}.tmp ${lib}.TOC ; fi; fi' % {'solink': solink_base, 'extract_toc': "{ otool -l $lib | grep LC_ID_DYLIB -A 5; nm -gP $lib | cut -f1-2 -d' ' | grep -v U$$; true; }", })
        solink_suffix = '$in $solibs $libs$postbuilds'
        master_ninja.rule('solink', description='SOLINK $lib, POSTBUILDS', restat=True, command=(mtime_preserving_solink_base % {'suffix': solink_suffix, 'type': '-shared', }), pool='link_pool')
        master_ninja.rule('solink_notoc', description='SOLINK $lib, POSTBUILDS', restat=True, command=(solink_base % {'suffix': solink_suffix, 'type': '-shared', }), pool='link_pool')
        solink_module_suffix = '$in $solibs $libs$postbuilds'
        master_ninja.rule('solink_module', description='SOLINK(module) $lib, POSTBUILDS', restat=True, command=(mtime_preserving_solink_base % {'suffix': solink_module_suffix, 'type': '-bundle', }), pool='link_pool')
        master_ninja.rule('solink_module_notoc', description='SOLINK(module) $lib, POSTBUILDS', restat=True, command=(solink_base % {'suffix': solink_module_suffix, 'type': '-bundle', }), pool='link_pool')
        master_ninja.rule('link', description='LINK $out, POSTBUILDS', command='$ld $ldflags -o $out $in $solibs $libs$postbuilds', pool='link_pool')
        master_ninja.rule('preprocess_infoplist', description='PREPROCESS INFOPLIST $out', command='$cc -E -P -Wno-trigraphs -x c $defines $in -o $out && plutil -convert xml1 $out $out')
        master_ninja.rule('copy_infoplist', description='COPY INFOPLIST $in', command='$env ./gyp-mac-tool copy-info-plist $in $out $keys')
        master_ninja.rule('mac_tool', description='MACTOOL $mactool_cmd $in', command='$env ./gyp-mac-tool $mactool_cmd $in $out')
        master_ninja.rule('package_framework', description='PACKAGE FRAMEWORK $out, POSTBUILDS', command='./gyp-mac-tool package-framework $out $version$postbuilds && touch $out')
    if (flavor == 'win'):
        master_ninja.rule('stamp', description='STAMP $out', command=('%s gyp-win-tool stamp $out' % sys.executable))
        master_ninja.rule('copy', description='COPY $in $out', command=('%s gyp-win-tool recursive-mirror $in $out' % sys.executable))
    else:
        master_ninja.rule('stamp', description='STAMP $out', command='${postbuilds}touch $out')
        master_ninja.rule('copy', description='COPY $in $out', command='rm -rf $out && cp -af $in $out')
    master_ninja.newline()
    all_targets = set()
    for build_file in params['build_files']:
        for target in gyp.common.AllTargets(target_list, target_dicts, os.path.normpath(build_file)):
            all_targets.add(target)
    all_outputs = set()
    target_outputs = {}
    target_short_names = {}
    for qualified_target in target_list:
        (build_file, name, toolset) = gyp.common.ParseQualifiedTarget(qualified_target)
        this_make_global_settings = data[build_file].get('make_global_settings', [])
        assert (make_global_settings == this_make_global_settings), 'make_global_settings needs to be the same for all targets.'
        spec = target_dicts[qualified_target]
        if (flavor == 'mac'):
            gyp.xcode_emulation.MergeGlobalXcodeSettingsToSpec(data[build_file], spec)
        build_file = gyp.common.RelativePath(build_file, options.toplevel_dir)
        base_path = os.path.dirname(build_file)
        obj = 'obj'
        if (toolset != 'target'):
            obj += ('.' + toolset)
        output_file = os.path.join(obj, base_path, (name + '.ninja'))
        ninja_output = StringIO()
        writer = NinjaWriter(qualified_target, target_outputs, base_path, build_dir, ninja_output, toplevel_build, output_file, flavor, toplevel_dir=options.toplevel_dir)
        target = writer.WriteSpec(spec, config_name, generator_flags)
        if (ninja_output.tell() > 0):
            with OpenOutput(os.path.join(toplevel_build, output_file)) as ninja_file:
                ninja_file.write(ninja_output.getvalue())
            ninja_output.close()
            master_ninja.subninja(output_file)
        if target:
            if ((name != target.FinalOutput()) and (spec['toolset'] == 'target')):
                target_short_names.setdefault(name, []).append(target)
            target_outputs[qualified_target] = target
            if (qualified_target in all_targets):
                all_outputs.add(target.FinalOutput())
    if target_short_names:
        master_ninja.newline()
        master_ninja.comment('Short names for targets.')
        for short_name in target_short_names:
            master_ninja.build(short_name, 'phony', [x.FinalOutput() for x in target_short_names[short_name]])
    if all_outputs:
        master_ninja.newline()
        master_ninja.build('all', 'phony', list(all_outputs))
        master_ninja.default(generator_flags.get('default_target', 'all'))
